"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const validator_1 = __importDefault(require("validator"));
const eventsource_1 = __importDefault(require("eventsource"));
const url_1 = __importDefault(require("url"));
const querystring_1 = __importDefault(require("querystring"));
class Client {
    constructor({ source, target, logger = console, fetch = global.fetch, }) {
        this.source = source;
        this.target = target;
        this.logger = logger;
        this.fetch = fetch;
        if (!validator_1.default.isURL(this.source)) {
            throw new Error("The provided URL is invalid.");
        }
    }
    static async createChannel({ fetch = global.fetch } = {}) {
        const response = await fetch("https://smee.io/new", {
            method: "HEAD",
            redirect: "manual",
        });
        const address = response.headers.get("location");
        if (!address) {
            throw new Error("Failed to create channel");
        }
        return address;
    }
    async onmessage(msg) {
        const data = JSON.parse(msg.data);
        const target = url_1.default.parse(this.target, true);
        const mergedQuery = { ...target.query, ...data.query };
        target.search = querystring_1.default.stringify(mergedQuery);
        delete data.query;
        const body = JSON.stringify(data.body);
        delete data.body;
        const headers = {};
        Object.keys(data).forEach((key) => {
            headers[key] = data[key];
        });
        headers["content-length"] = Buffer.byteLength(body);
        try {
            const response = await this.fetch(url_1.default.format(target), {
                method: "POST",
                mode: data["sec-fetch-mode"],
                cache: "default",
                body,
                headers,
            });
            this.logger.info(`POST ${response.url} - ${response.status}`);
        }
        catch (err) {
            this.logger.error(err);
        }
    }
    onopen() {
        this.logger.info("Connected", this.events.url);
    }
    onerror(err) {
        this.logger.error(err);
    }
    start() {
        const events = new eventsource_1.default(this.source);
        // Reconnect immediately
        events.reconnectInterval = 0; // This isn't a valid property of EventSource
        events.addEventListener("message", this.onmessage.bind(this));
        events.addEventListener("open", this.onopen.bind(this));
        events.addEventListener("error", this.onerror.bind(this));
        this.logger.info(`Forwarding ${this.source} to ${this.target}`);
        this.events = events;
        return events;
    }
}
module.exports = Client;
//# sourceMappingURL=index.js.map